{% extends "base.html" %}

{% block title %}Tag By Image{% endblock %}

{% block extra_css %}
<style>
    .tag-by-image-layout {
        display: flex;
        gap: 1.5rem;
        height: calc(100vh - 250px);
        min-height: 500px;
        max-height: 900px;
    }

    .tag-sidebar {
        flex: 0 0 400px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .tag-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .media-info {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 1.25rem;
        flex-shrink: 0;
    }

    .media-counter {
        font-size: 1rem;
        color: #667eea;
        font-weight: 500;
        margin-bottom: 0.5rem;
    }

    .media-filename {
        font-size: 1.1rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 0.5rem;
        word-break: break-word;
    }

    .media-path {
        color: #666;
        font-family: monospace;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.05);
        padding: 0.4rem;
        border-radius: 4px;
        word-break: break-all;
        margin-bottom: 0.5rem;
    }

    .media-dimensions {
        font-size: 0.9rem;
        color: #667eea;
        font-weight: 500;
    }

    .dimensions-text {
        background: rgba(102, 126, 234, 0.1);
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        display: inline-block;
    }

    .tagging-panel {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 1.5rem;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    

    .current-tag-info {
        text-align: center;
        margin-bottom: 1rem;
    }

    .current-tag-name {
        font-size: 1.3rem;
        font-weight: 600;
        color: #667eea;
        margin-bottom: 0.5rem;
    }

    .current-tag-description {
        color: #666;
        font-size: 1rem;
        line-height: 1.4;
        margin-bottom: 1rem;
    }

    .tag-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .tag-option {
        background: white;
        border: 2px solid #ddd;
        border-radius: 8px;
        padding: 1rem;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
        text-align: center;
    }

    .tag-option:hover {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
        transform: translateY(-1px);
    }

    .tag-option.selected {
        background: #667eea;
        color: white;
        border-color: #667eea;
    }

    .tag-option.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #f5f5f5;
    }

         .completion-status {
         text-align: center;
         padding: 1rem;
         background: rgba(102, 126, 234, 0.1);
         border-radius: 8px;
     }

    .completion-status h4 {
        color: #667eea;
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    .completion-status p {
        color: #666;
        font-size: 0.9rem;
        margin: 0;
    }

    .navigation {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        flex-shrink: 0;
    }

    .nav-btn {
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.5rem;
        transition: all 0.3s ease;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .nav-btn:hover:not(:disabled) {
        background: #667eea;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .media-display {
        background: rgba(0, 0, 0, 0.8);
        border-radius: 16px;
        padding: 1rem;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        min-height: 0;
        overflow: hidden;
    }

    .media-display img,
    .media-display video {
        max-width: 100%;
        max-height: 100%;
        border-radius: 8px;
        object-fit: contain;
    }

    .no-media {
        color: #666;
        text-align: center;
        font-size: 1.1rem;
    }

    .fade-in {
        animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .no-tags-message {
        text-align: center;
        color: #666;
        font-style: italic;
        padding: 2rem;
    }

    

    
     
           .tag-navigation {
          display: flex;
          justify-content: flex-start;
          align-items: center;
          margin-bottom: 1rem;
      }
     
     .nav-btn-small {
         background: rgba(102, 126, 234, 0.1);
         border: 2px solid #667eea;
         border-radius: 8px;
         padding: 0.5rem 1rem;
         color: #667eea;
         cursor: pointer;
         font-size: 0.9rem;
         font-weight: 500;
         transition: all 0.3s ease;
     }
     
     .nav-btn-small:hover {
         background: #667eea;
         color: white;
         transform: translateY(-1px);
     }
     
     .nav-btn-small:disabled {
         opacity: 0.5;
         cursor: not-allowed;
         transform: none;
     }
     
     .next-event-btn {
         background: #4caf50;
         border: none;
         border-radius: 8px;
         padding: 0.75rem 1.5rem;
         color: white;
         cursor: pointer;
         font-size: 1rem;
         font-weight: 600;
         transition: all 0.3s ease;
         margin-top: 1rem;
     }
     
     .next-event-btn:hover {
         background: #45a049;
         transform: translateY(-2px);
         box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
     }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1 style="text-align: center; margin-bottom: 1rem; color: #667eea;">Tag By Image</h1>
    
    <div class="tag-by-image-layout">
        <div class="tag-sidebar">
                         <div id="mediaInfo" class="media-info" style="display: none;">
                 <div class="media-counter" id="mediaCounter"></div>
                 <div class="media-filename" id="mediaFilename"></div>
                 <div class="media-path" id="mediaPath"></div>
                 <div class="media-dimensions" id="mediaDimensions" style="display: none;">
                     <span class="dimensions-text">
                         <span id="mediaWidth">-</span> × <span id="mediaHeight">-</span>
                     </span>
                 </div>
             </div>
             
             <div class="completion-status" id="completionStatus" style="display: none;">
                 <h4>All Tags Complete!</h4>
                 <p id="completionText"></p>
                 <button class="next-event-btn" id="nextEventBtn" onclick="nextEvent()">
                     Next Event ›
                 </button>
             </div>
             
             <div class="tagging-panel" id="taggingPanel" style="display: none;">
                 <div class="tag-navigation" id="tag-navigation" style="display: none;">
                     <button class="nav-btn-small" id="prevTagBtn" onclick="previousTag()" style="display: none;">‹ Previous</button>
                 </div>
                 
                 <div class="current-tag-info">
                     <div class="current-tag-name" id="currentTagName"></div>
                     <div class="current-tag-description" id="currentTagDescription"></div>
                 </div>
                 
                 <div class="tag-options" id="tagOptions">
                     <!-- Tag options will be populated here -->
                 </div>
             </div>
            
            <div class="navigation" id="navigation" style="display: none;">
                <button class="nav-btn" id="prevBtn" onclick="previousMedia()">‹</button>
                <button class="nav-btn" id="nextBtn" onclick="nextMedia()">›</button>
            </div>
        </div>
        
        <div class="tag-main">
            <div class="media-display" id="mediaDisplay">
                <div class="no-media">No media files found. Upload some files first!</div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let mediaList = [];
let currentIndex = 0;
let tagConfig = {};
let currentTags = {};
let allTags = [];
let currentTagIndex = 0;
let tagDependencies = {}; // Track dependencies for each tag
let currentTagPosition = -1; // Current position in the ordered tags array
let answeredTagPositions = []; // Track positions of answered tags

// Load media list and tag configuration on page load
document.addEventListener('DOMContentLoaded', function() {
    loadMediaList();
    loadTagConfiguration();
});

async function loadMediaList() {
    try {
        const response = await fetch('/api/media');
        mediaList = await response.json();
        
        if (mediaList.length > 0) {
            // Find the first media that needs tagging
            let foundMediaNeedingTagging = false;
            for (let i = 0; i < mediaList.length; i++) {
                await loadCurrentTags(mediaList[i].path);
                if (!isMediaFullyTagged()) {
                    await showMedia(i);
                    document.getElementById('navigation').style.display = 'flex';
                    foundMediaNeedingTagging = true;
                    break;
                }
            }
            
            if (!foundMediaNeedingTagging) {
                showNoMediaNeedsTagging();
            }
        } else {
            document.getElementById('mediaDisplay').innerHTML = 
                '<div class="no-media">No media files found. Upload some files first!</div>';
        }
    } catch (error) {
        console.error('Error loading media list:', error);
        document.getElementById('mediaDisplay').innerHTML = 
            '<div class="no-media">Error loading media files.</div>';
    }
}

async function loadTagConfiguration() {
    try {
        const response = await fetch('/api/tags/config');
        tagConfig = await response.json();
        
        
        // Extract all tags in order from the YAML
        if (tagConfig.tags) {
            allTags = Object.keys(tagConfig.tags);
            // Analyze dependencies for each tag
            try {
                analyzeTagDependencies();
            } catch (error) {
                console.error('Error analyzing tag dependencies:', error);
                // Show error in UI
                document.getElementById('mediaDisplay').innerHTML = `
                    <div class="no-media" style="color: #c62828; background: #ffebee; padding: 2rem; border-radius: 8px; border: 1px solid #ef5350;">
                        <h3>Configuration Error</h3>
                        <p><strong>Failed to analyze tag dependencies:</strong></p>
                        <p>${error.message}</p>
                        <p><small>Please check your events_tags.yaml file for syntax errors.</small></p>
                    </div>
                `;
                return;
            }
        }
    } catch (error) {
        console.error('Error loading tag configuration:', error);
        // Show error in UI
        document.getElementById('mediaDisplay').innerHTML = `
            <div class="no-media" style="color: #c62828; background: #ffebee; padding: 2rem; border-radius: 8px; border: 1px solid #ef5350;">
                <h3>Configuration Error</h3>
                <p><strong>Failed to load tag configuration:</strong></p>
                <p>${error.message}</p>
                <p><small>Please check your events_tags.yaml file and ensure the server is running.</small></p>
            </div>
        `;
        tagConfig = { tags: {} };
        allTags = [];
        tagDependencies = {};
    }
}

function analyzeTagDependencies() {
    try {
        tagDependencies = {};
        
        for (const tagName of allTags) {
            try {
                const tagInfo = tagConfig.tags[tagName];
                const dependencies = new Set();
                
                // Check tag-level requirements
                if (tagInfo.req) {
                    const tagDeps = extractVariablesFromCondition(tagInfo.req);
                    tagDeps.forEach(dep => dependencies.add(dep));
                }
                
                // Check value-level requirements
                if (tagInfo.values) {
                    for (const valueItem of tagInfo.values) {
                        if (typeof valueItem === 'object' && valueItem.req) {
                            const valueDeps = extractVariablesFromCondition(valueItem.req);
                            valueDeps.forEach(dep => dependencies.add(dep));
                        }
                    }
                }
                
                tagDependencies[tagName] = Array.from(dependencies);
            } catch (error) {
                console.error(`Error analyzing dependencies for tag ${tagName}:`, error);
                // Continue with other tags, but mark this one as having an error
                tagDependencies[tagName] = [];
                throw new Error(`Failed to analyze dependencies for tag '${tagName}': ${error.message}`);
            }
        }
        
        
    } catch (error) {
        console.error('Error analyzing tag dependencies:', error);
        throw new Error(`Failed to analyze tag dependencies: ${error.message}`);
    }
}

function tokenizeCondition(input) {
	const tokens = [];
	let i = 0;
	const length = input.length;
	const isWhitespace = c => /\s/.test(c);
	const isDigit = c => /[0-9]/.test(c);
	const isIdentifierStart = c => /[A-Za-z_]/.test(c);
	const isIdentifierPart = c => /[A-Za-z0-9_]/.test(c);
	while (i < length) {
		const char = input[i];
		if (isWhitespace(char)) { i++; continue; }
		// Operators (two-char first)
		if (i + 1 < length) {
			const two = input.slice(i, i + 2);
			if (two === '&&' || two === '||' || two === '==' || two === '!=' || two === '>=' || two === '<=') {
				tokens.push({ type: 'op', value: two });
				i += 2;
				continue;
			}
		}
		// Single char operators / parens
		if (char === '>' || char === '<' || char === '(' || char === ')') {
			tokens.push({ type: char === '(' || char === ')' ? (char === '(' ? 'lparen' : 'rparen') : 'op', value: char });
			i++;
			continue;
		}
		// String literal
		if (char === '"') {
			let j = i + 1;
			let str = '';
			while (j < length) {
				if (input[j] === '"') { break; }
				// Support escaped quotes \"
				if (input[j] === '\\' && j + 1 < length && input[j+1] === '"') { str += '"'; j += 2; continue; }
				str += input[j];
				j++;
			}
			if (j >= length || input[j] !== '"') {
				throw new Error('Unterminated string literal');
			}
			tokens.push({ type: 'string', value: str });
			i = j + 1;
			continue;
		}
		// Number
		if (isDigit(char)) {
			let j = i;
			while (j < length && (isDigit(input[j]) || input[j] === '.')) j++;
			const numStr = input.slice(i, j);
			const num = parseFloat(numStr);
			if (Number.isNaN(num)) {
				throw new Error(`Invalid number: ${numStr}`);
			}
			tokens.push({ type: 'number', value: num });
			i = j;
			continue;
		}
		// Identifier
		if (isIdentifierStart(char)) {
			let j = i + 1;
			while (j < length && isIdentifierPart(input[j])) j++;
			const ident = input.slice(i, j);
			tokens.push({ type: 'identifier', value: ident });
			i = j;
			continue;
		}
		throw new Error(`Unexpected character: ${char}`);
	}
	return tokens;
}

function extractVariablesFromCondition(condition) {
	const variables = new Set();
	if (!condition) return variables;
	try {
		const tokens = tokenizeCondition(condition);
		for (const t of tokens) {
			if (t.type === 'identifier') variables.add(t.value);
		}
		return variables;
	} catch (error) {
		console.error('Error extracting variables from condition:', condition, error);
		throw new Error(`Failed to parse condition: ${condition}`);
	}
}

function evaluateCondition(condition) {
	if (!condition) return true;
	try {
		const tokens = tokenizeCondition(condition);
		const state = { tokens, index: 0 };
		const result = parseOrExpression(state);
		if (state.index !== tokens.length) {
			throw new Error('Unexpected extra tokens at end of expression');
		}
		return result;
	} catch (error) {
		console.error('Error evaluating condition:', condition, error);
		throw new Error(`Failed to evaluate condition: ${condition}`);
	}
}

function parseOrExpression(state) {
	let value = parseAndExpression(state);
	while (matchOp(state, '||')) {
		const rhs = parseAndExpression(state);
		value = Boolean(value || rhs);
	}
	return value;
}

function parseAndExpression(state) {
	let value = parsePrimary(state);
	while (matchOp(state, '&&')) {
		const rhs = parsePrimary(state);
		value = Boolean(value && rhs);
	}
	return value;
}

function parsePrimary(state) {
	if (matchType(state, 'lparen')) {
		const value = parseOrExpression(state);
		expectType(state, 'rparen', 'Expected closing parenthesis ")"');
		return value;
	}
	return parseComparisonOrIdentifier(state);
}

function parseComparisonOrIdentifier(state) {
	const identToken = expectType(state, 'identifier', 'Expected identifier');
	const leftValRaw = getIdentifierValue(identToken.value);
	// Look ahead for comparator
	const op = peekOp(state);
	if (op && (op === '==' || op === '!=' || op === '>=' || op === '<=' || op === '>' || op === '<')) {
		state.index++; // consume op
		const right = parseValue(state);
		return compareValues(leftValRaw, right, op);
	}
	// Truthiness of identifier when no comparator
	return isTruthy(leftValRaw);
}

function parseValue(state) {
	const tok = current(state);
	if (!tok) throw new Error('Expected value');
	if (tok.type === 'number') { state.index++; return tok.value; }
	if (tok.type === 'string') { state.index++; return tok.value; }
	if (tok.type === 'identifier') { state.index++; return getIdentifierValue(tok.value); }
	throw new Error('Expected a value (number, string, or identifier)');
}

function getIdentifierValue(name) {
	// Read from currentTags; may be undefined
	return currentTags ? currentTags[name] : undefined;
}

function compareValues(left, right, op) {
	// Handle "many" as a special value (treat as 100 for numeric comparisons)
	const normalizeValue = (val) => {
		if (val === "many") return 100;
		if (val !== undefined && val !== null && val !== '' && !isNaN(Number(val))) return Number(val);
		return null;
	};
	
	const leftNum = normalizeValue(left);
	const rightNum = normalizeValue(right);
	
	if (op === '>' || op === '<' || op === '>=' || op === '<=') {
		if (leftNum === null || rightNum === null) {
			throw new Error(`Numeric comparison requires numbers: ${left} ${op} ${right}`);
		}
		switch (op) {
			case '>': return leftNum > rightNum;
			case '<': return leftNum < rightNum;
			case '>=': return leftNum >= rightNum;
			case '<=': return leftNum <= rightNum;
		}
	}
	// Equality/inequality: if both numeric-like, compare numerically; else string compare
	if (op === '==' || op === '!=') {
		let result;
		if (leftNum !== null && rightNum !== null) {
			result = leftNum === rightNum;
		} else {
			result = `${left}` === `${right}`;
		}
		return op === '==' ? result : !result;
	}
	throw new Error(`Unknown operator: ${op}`);
}

function isTruthy(value) {
	if (value === undefined || value === null) return false;
	if (typeof value === 'number') return value !== 0;
	if (typeof value === 'string') return value.trim() !== '' && value !== '0';
	return Boolean(value);
}

function current(state) { return state.tokens[state.index]; }
function matchType(state, type) {
	const tok = current(state);
	if (tok && tok.type === type) { state.index++; return true; }
	return false;
}
function expectType(state, type, message) {
	const tok = current(state);
	if (!tok || tok.type !== type) { throw new Error(message || `Expected ${type}`); }
	state.index++;
	return tok;
}
function matchOp(state, op) {
	const tok = current(state);
	if (tok && tok.type === 'op' && tok.value === op) { state.index++; return true; }
	return false;
}
function peekOp(state) {
	const tok = current(state);
	return tok && tok.type === 'op' ? tok.value : null;
}

function getOrderedTags() {
    const orderedTags = [];
    const resolvedTags = new Set();
    
    // Process tags in their original order
    for (const tagName of allTags) {
        const dependencies = tagDependencies[tagName] || [];
        const allDependenciesResolved = dependencies.every(dep => resolvedTags.has(dep));
        
        if (allDependenciesResolved) {
            orderedTags.push(tagName);
            resolvedTags.add(tagName);
        } else {
            // Skip this tag for now, it will be processed later when dependencies are resolved
            
        }
    }
    
    // Check for any unresolved tags (circular dependencies)
    const unresolvedTags = allTags.filter(tag => !resolvedTags.has(tag));
    if (unresolvedTags.length > 0) {
        
        // Add unresolved tags at the end in original order
        orderedTags.push(...unresolvedTags);
    }
    
    return orderedTags;
}

async function showMedia(index) {
    if (index < 0 || index >= mediaList.length) return;
    
    // Stop any currently playing video before switching
    const currentVideo = document.querySelector('#mediaDisplay video');
    if (currentVideo) {
        currentVideo.pause();
        currentVideo.currentTime = 0;
    }
    
    currentIndex = index;
    const media = mediaList[index];
    
    // Load current tags for this media first
    await loadCurrentTags(media.path);
    
    // Check if this media is fully tagged
    if (isMediaFullyTagged()) {
        // Skip to next media
        if (index < mediaList.length - 1) {
            await showMedia(index + 1);
        } else {
            // We've reached the end, try going backwards
            for (let i = index - 1; i >= 0; i--) {
                await loadCurrentTags(mediaList[i].path);
                if (!isMediaFullyTagged()) {
                    await showMedia(i);
                    return;
                }
            }
            // No media needs tagging
            showNoMediaNeedsTagging();
            return;
        }
        return;
    }
    
    // Update navigation buttons
    document.getElementById('prevBtn').disabled = index === 0;
    document.getElementById('nextBtn').disabled = index === mediaList.length - 1;
    
    // Update media info
    document.getElementById('mediaInfo').style.display = 'block';
    document.getElementById('mediaCounter').textContent = `${index + 1} of ${mediaList.length}`;
    document.getElementById('mediaFilename').textContent = media.path.split('/').pop();
    document.getElementById('mediaPath').textContent = media.path;
    
    // Load dimensions if available
    try {
        const mediaResponse = await fetch(`/api/media/${index}`);
        const mediaInfo = await mediaResponse.json();
        
        if (mediaInfo.width && mediaInfo.height) {
            document.getElementById('mediaDimensions').style.display = 'block';
            document.getElementById('mediaWidth').textContent = mediaInfo.width;
            document.getElementById('mediaHeight').textContent = mediaInfo.height;
        } else {
            document.getElementById('mediaDimensions').style.display = 'none';
        }
    } catch (error) {
        console.warn('Could not load media dimensions:', error);
        document.getElementById('mediaDimensions').style.display = 'none';
    }
    
    // Display media
    displayMedia(media);
    
    // Start the tagging process
    startTaggingProcess();
}

function displayMedia(media) {
    const mediaDisplay = document.getElementById('mediaDisplay');
    
    // Determine if it's an image or video
    const filename = media.path.toLowerCase();
    const isVideo = filename.endsWith('.mp4') || filename.endsWith('.webm') || filename.endsWith('.gif');
    
    if (isVideo) {
        const video = document.createElement('video');
        video.src = '/' + media.path;
        video.controls = true;
        video.autoplay = true;
        video.muted = true;
        video.loop = true;
        video.className = 'fade-in';
        
        // Enable audio after video starts playing
        video.addEventListener('play', () => {
            setTimeout(() => {
                video.muted = false;
            }, 100);
        });
        
        video.onloadstart = () => {
            mediaDisplay.innerHTML = '';
            mediaDisplay.appendChild(video);
        };
        video.onerror = () => {
            mediaDisplay.innerHTML = 
                '<div class="no-media">Error loading video file.</div>';
        };
    } else {
        const img = document.createElement('img');
        img.src = '/' + media.path;
        img.className = 'fade-in';
        img.onload = () => {
            mediaDisplay.innerHTML = '';
            mediaDisplay.appendChild(img);
        };
        img.onerror = () => {
            mediaDisplay.innerHTML = 
                '<div class="no-media">Error loading image file.</div>';
        };
    }
}

async function loadCurrentTags(mediaPath) {
    try {
        const response = await fetch(`/api/tags/media/${encodeURIComponent(mediaPath)}`);
        currentTags = await response.json();
    } catch (error) {
        console.warn('Could not load current tags:', error);
        currentTags = {};
    }
}

function startTaggingProcess() {
    currentTagIndex = 0;
    currentTagPosition = -1;
    answeredTagPositions = [];
    
    // Add already answered tags to the positions array
    const orderedTags = getOrderedTags();
    for (let i = 0; i < orderedTags.length; i++) {
        const tagName = orderedTags[i];
        if (currentTags[tagName] !== undefined && currentTags[tagName] !== null) {
            answeredTagPositions.push(i);
        }
    }
    
    
    showNextTag();
}

function showNextTag() {
    try {
        const nextTag = findNextUnansweredTag();
        
                 if (nextTag) {
             const shouldShow = showTagQuestion(nextTag);
             if (!shouldShow) {
                 // Tag was shown but has no valid options (all conditions unmet)
                 // Skip to the next tag
                 showNextTag();
             }
         } else {
             showCompletionStatus();
         }
    } catch (error) {
        console.error('Error showing next tag:', error);
        // Display error in the UI
        const taggingPanel = document.getElementById('taggingPanel');
        const completionStatus = document.getElementById('completionStatus');
                 const currentTagName = document.getElementById('currentTagName');
         const currentTagDescription = document.getElementById('currentTagDescription');
         const tagOptionsContainer = document.getElementById('tagOptions');
         
         if (taggingPanel) taggingPanel.style.display = 'block';
         if (completionStatus) completionStatus.style.display = 'none';
         
         if (currentTagName) currentTagName.textContent = 'Error';
         if (currentTagDescription) currentTagDescription.textContent = 'An error occurred while processing tags.';
         
         if (tagOptionsContainer) {
             tagOptionsContainer.innerHTML = `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
                 <strong>System Error:</strong><br>
                 ${error.message}<br><br>
                 <small>Please check the browser console for more details.</small>
             </div>`;
         }
    }
}

function findNextUnansweredTag() {
    try {
        const orderedTags = getOrderedTags();
        
        // Start from the position after the current tag
        const startIndex = currentTagPosition + 1;
        
        for (let i = startIndex; i < orderedTags.length; i++) {
            const tagName = orderedTags[i];
            const tagInfo = tagConfig.tags[tagName];
            
            // Skip if already answered
            if (currentTags[tagName] !== undefined && currentTags[tagName] !== null) {
                continue;
            }
            
            // Check if all dependencies are satisfied
            const dependencies = tagDependencies[tagName] || [];
            const allDependenciesSatisfied = dependencies.every(dep => 
                currentTags[dep] !== undefined && currentTags[dep] !== null
            );
            
            if (!allDependenciesSatisfied) {
                continue; // Skip this tag until dependencies are resolved
            }
            
            // Check if tag is applicable based on req condition
            const tagApplicable = isTagApplicable(tagName, tagInfo);
            if (tagApplicable === true) {
                // Tag is applicable, check if it has any valid values
                const hasValidValues = checkTagHasValidValues(tagName, tagInfo);
                if (hasValidValues === true) {
                    currentTagPosition = i; // Update current position
                    return { name: tagName, info: tagInfo };
                }
                // If hasValidValues is false, skip this tag (no valid options)
                // If hasValidValues is an error, we'll handle it in showTagQuestion
            } else if (tagApplicable === false) {
                // Tag is not applicable, skip it
                continue;
            }
            // If tagApplicable is an error, we'll handle it in showTagQuestion
        }
        return null;
    } catch (error) {
        console.error('Error finding next unanswered tag:', error);
        throw new Error(`Failed to find next tag: ${error.message}`);
    }
}

function isTagApplicable(tagName, tagInfo) {
    try {
        if (!tagInfo.req) {
            return true; // No requirements, always applicable
        }
        
        // Parse and evaluate the req condition
        return evaluateCondition(tagInfo.req);
    } catch (error) {
        console.error('Error checking if tag is applicable:', tagName, tagInfo, error);
        return { error: `Failed to check applicability for tag ${tagName}: ${error.message}` };
    }
}

function checkTagHasValidValues(tagName, tagInfo) {
    try {
        if (tagInfo.values) {
            // Check if any values have valid conditions
            for (const valueItem of tagInfo.values) {
                try {
                    let condition;
                    
                    if (typeof valueItem === 'string') {
                        // Simple string value (backward compatibility)
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        // Conditional value with 'req' clause
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        // Value without condition
                        condition = null;
                    } else {
                        // Fallback for other formats
                        condition = null;
                    }
                    
                    // Check if this value should be shown based on condition
                    if (condition === null || evaluateCondition(condition)) {
                        return true; // Found at least one valid value
                    }
                } catch (error) {
                    console.error('Error processing value item:', valueItem, error);
                    return { error: `Failed to process value for tag ${tagName}: ${error.message}` };
                }
            }
            return false; // No valid values found
        } else if (tagInfo.type === 'int') {
            // Integer tag always has valid options
            return true;
        } else {
            // Default to boolean-like options
            return true;
        }
    } catch (error) {
        console.error('Error checking tag values:', tagName, tagInfo, error);
        return { error: `Failed to check values for tag ${tagName}: ${error.message}` };
    }
}

function isMediaFullyTagged() {
    try {
        const orderedTags = getOrderedTags();
        
        for (const tagName of orderedTags) {
            const tagInfo = tagConfig.tags[tagName];
            const dependencies = tagDependencies[tagName] || [];
            
            // Check if all dependencies are satisfied
            const allDependenciesSatisfied = dependencies.every(dep => 
                currentTags[dep] !== undefined && currentTags[dep] !== null
            );
            
            if (allDependenciesSatisfied) {
                // Check if tag is applicable
                const tagApplicable = isTagApplicable(tagName, tagInfo);
                if (tagApplicable === true) {
                    // Check if tag has valid values
                    const hasValidValues = checkTagHasValidValues(tagName, tagInfo);
                    if (hasValidValues === true) {
                        // Check if this tag is answered
                        if (currentTags[tagName] === undefined || currentTags[tagName] === null) {
                            return false; // Found a tag that needs answering
                        }
                    }
                    // If hasValidValues is false, this tag is skipped (no valid options)
                    // If hasValidValues is an error, we'll handle it elsewhere
                } else if (tagApplicable === false) {
                    // Tag is not applicable, skip it
                    continue;
                }
                // If tagApplicable is an error, we'll handle it elsewhere
            }
        }
        return true; // All applicable tags are answered
    } catch (error) {
        console.error('Error checking if media is fully tagged:', error);
        return false; // Assume not fully tagged if there's an error
    }
}

function showNoMediaNeedsTagging() {
         // Hide all panels
     const mediaInfo = document.getElementById('mediaInfo');
     const taggingPanel = document.getElementById('taggingPanel');
     const completionStatus = document.getElementById('completionStatus');
     const navigation = document.getElementById('navigation');
     const mediaDisplay = document.getElementById('mediaDisplay');
     
     if (mediaInfo) mediaInfo.style.display = 'none';
     if (taggingPanel) taggingPanel.style.display = 'none';
     if (completionStatus) completionStatus.style.display = 'none';
     if (navigation) navigation.style.display = 'none';
    
    // Show message
    if (mediaDisplay) {
        mediaDisplay.innerHTML = `
            <div class="no-media" style="color: #4caf50; background: #e8f5e8; padding: 2rem; border-radius: 8px; border: 1px solid #4caf50;">
                <h3>🎉 All Media Tagged!</h3>
                <p>All media files have been fully tagged and no further input is needed.</p>
                <p><small>You can upload new media files or modify existing tags in the Tag Manager.</small></p>
            </div>
        `;
    }
}

function showTagQuestion(tag) {
    try {
        const taggingPanel = document.getElementById('taggingPanel');
        const completionStatus = document.getElementById('completionStatus');
        const currentTagName = document.getElementById('currentTagName');
        const currentTagDescription = document.getElementById('currentTagDescription');
        
                 if (taggingPanel) taggingPanel.style.display = 'block';
        if (completionStatus) completionStatus.style.display = 'none';
        
        if (currentTagName) currentTagName.textContent = tag.name;
        if (currentTagDescription) currentTagDescription.textContent = tag.info.desc || tag.info.description || 'No description available';
        
        const tagOptionsContainer = document.getElementById('tagOptions');
        if (!tagOptionsContainer) {
            console.error('Tag options container not found');
            return false;
        }
        
        let html = '';
        let hasValidOptions = false;
        let hasErrors = false;
        
        if (tag.info.values) {
            // Handle conditional values with 'req' clauses
            for (const valueItem of tag.info.values) {
                try {
                    let value, condition;
                    
                    if (typeof valueItem === 'string') {
                        // Simple string value (backward compatibility)
                        value = valueItem;
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        // Conditional value with 'req' clause
                        value = valueItem.value;
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        // Value without condition
                        value = valueItem.value;
                        condition = null;
                    } else {
                        // Fallback for other formats
                        value = valueItem;
                        condition = null;
                    }
                    
                    // Check if this value should be shown based on condition
                    if (condition === null || evaluateCondition(condition)) {
                        const isSelected = currentTags[tag.name] === value;
                        const selectedClass = isSelected ? ' selected' : '';
                        html += `<div class="tag-option${selectedClass}" onclick="selectTagValue('${tag.name}', '${value}')">${value}</div>`;
                        hasValidOptions = true;
                    }
                } catch (error) {
                    console.error('Error processing value item:', valueItem, error);
                    html += `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
                        <strong>Error:</strong> ${valueItem.value || 'Unknown value'} - ${error.message}
                    </div>`;
                    hasErrors = true;
                }
            }
        } else if (tag.info.type === 'int') {
            // Integer tag - provide common options
            const options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            for (const value of options) {
                const isSelected = currentTags[tag.name] === value.toString();
                const selectedClass = isSelected ? ' selected' : '';
                html += `<div class="tag-option${selectedClass}" onclick="selectTagValue('${tag.name}', '${value}')">${value}</div>`;
                hasValidOptions = true;
            }
        } else {
            // Default to boolean-like options
            const yesSelected = currentTags[tag.name] === 'yes' ? ' selected' : '';
            const noSelected = currentTags[tag.name] === 'no' ? ' selected' : '';
            html += `<div class="tag-option${yesSelected}" onclick="selectTagValue('${tag.name}', 'yes')">Yes</div>`;
            html += `<div class="tag-option${noSelected}" onclick="selectTagValue('${tag.name}', 'no')">No</div>`;
            hasValidOptions = true;
        }
        
        if (!hasValidOptions && !hasErrors) {
            // No valid options and no errors - this means all conditions were parsed but none were met
            // Don't show this tag at all, it should be skipped
            return false;
        }
        
        tagOptionsContainer.innerHTML = html;
        
                 // Show navigation buttons
         const tagNavigation = document.getElementById('tag-navigation');
         const prevTagBtn = document.getElementById('prevTagBtn');
         
         if (tagNavigation) tagNavigation.style.display = 'flex';
                 // Show previous button if there are any answered tags for this media
         const hasAnsweredTags = answeredTagPositions.length > 0;
         if (prevTagBtn) prevTagBtn.style.display = hasAnsweredTags ? 'block' : 'none';
        
        return true;
    } catch (error) {
        console.error('Error showing tag question:', tag, error);
        const tagOptionsContainer = document.getElementById('tagOptions');
        tagOptionsContainer.innerHTML = `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
            <strong>Error displaying tag:</strong> ${tag.name}<br>
            ${error.message}
        </div>`;
        return true; // Show the error
    }
}



function showCompletionStatus() {
         document.getElementById('taggingPanel').style.display = 'none';
     document.getElementById('completionStatus').style.display = 'block';
    
         document.getElementById('completionText').textContent = 
         `All applicable tags completed for this media!`;
    
    // Show the "Next Event" button instead of auto-advancing
    const nextEventBtn = document.getElementById('nextEventBtn');
    if (nextEventBtn) nextEventBtn.style.display = 'block';
}

async function selectTagValue(tagName, value) {
    // Save the tag value
    currentTags[tagName] = value;
    
    // Add current position to answered positions if not already there
    if (!answeredTagPositions.includes(currentTagPosition)) {
        answeredTagPositions.push(currentTagPosition);
    }
    
    // Save to server
    await saveCurrentTags();
    
    // Show next tag or completion
    showNextTag();
}



async function previousTag() {
    const orderedTags = getOrderedTags();
    
    if (answeredTagPositions.length === 0) {
        return; // No answered tags to navigate to
    }
    
    // Find the target position to go back to
    let targetPosition;
    
    // If we're currently at an answered tag, go to the previous one
    if (answeredTagPositions.includes(currentTagPosition)) {
        const currentIndex = answeredTagPositions.indexOf(currentTagPosition);
        if (currentIndex > 0) {
            // Go to the previous answered tag
            targetPosition = answeredTagPositions[currentIndex - 1];
        } else {
            // We're at the first answered tag, go to the very first tag
            targetPosition = 0;
        }
    } else {
        // We're not currently at an answered tag, go to the most recent answered tag
        targetPosition = Math.max(...answeredTagPositions);
    }
    
         // Clear all tags that come after the target position
     for (let i = targetPosition + 1; i < orderedTags.length; i++) {
         const tagName = orderedTags[i];
         if (currentTags[tagName] !== undefined && currentTags[tagName] !== null) {
             delete currentTags[tagName];
         }
     }
     
     // Update answeredTagPositions to only include positions up to targetPosition
     answeredTagPositions = answeredTagPositions.filter(pos => pos <= targetPosition);
     
     // Save the cleared tags to the server
     await saveCurrentTags();
     
     // Set current position to target
     currentTagPosition = targetPosition;
    
    // Show the target tag
    const targetTagName = orderedTags[targetPosition];
    const targetTagInfo = tagConfig.tags[targetTagName];
    
    if (targetTagInfo) {
        showTagQuestion({ name: targetTagName, info: targetTagInfo });
    }
}

async function nextEvent() {
    // Auto-advance to next media
    await nextMedia();
}

async function saveCurrentTags() {
    if (mediaList.length === 0) return;
    
    const currentMedia = mediaList[currentIndex];
    
    try {
        const response = await fetch(`/api/tags/media/${encodeURIComponent(currentMedia.path)}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(currentTags)
        });
        
        if (!response.ok) {
            throw new Error('Failed to save tags');
        }
    } catch (error) {
        console.error('Error saving tags:', error);
        // Could show a user-friendly error message here
    }
}

async function previousMedia() {
    if (currentIndex > 0) {
        // Find the previous media that needs tagging
        for (let i = currentIndex - 1; i >= 0; i--) {
            await loadCurrentTags(mediaList[i].path);
            if (!isMediaFullyTagged()) {
                await showMedia(i);
                return;
            }
        }
        // No previous media needs tagging
        showNoMediaNeedsTagging();
    }
}

async function nextMedia() {
    if (currentIndex < mediaList.length - 1) {
        // Find the next media that needs tagging
        for (let i = currentIndex + 1; i < mediaList.length; i++) {
            await loadCurrentTags(mediaList[i].path);
            if (!isMediaFullyTagged()) {
                await showMedia(i);
                return;
            }
        }
        // No next media needs tagging, try going backwards
        for (let i = currentIndex - 1; i >= 0; i--) {
            await loadCurrentTags(mediaList[i].path);
            if (!isMediaFullyTagged()) {
                await showMedia(i);
                return;
            }
        }
        // No media needs tagging
        showNoMediaNeedsTagging();
    }
}

// Keyboard navigation
document.addEventListener('keydown', async (e) => {
    if (mediaList.length === 0) return;
    
    switch(e.key) {
        case 'ArrowLeft':
            e.preventDefault();
            await previousMedia();
            break;
        case 'ArrowRight':
            e.preventDefault();
            await nextMedia();
            break;
        
        case 'Backspace':
            e.preventDefault();
            previousTag();
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '0':
            e.preventDefault();
            // Quick number selection for current tag
            const currentTag = findNextUnansweredTag();
            if (currentTag && currentTag.info.values) {
                // Get available values (filtered by conditions)
                const availableValues = [];
                for (const valueItem of currentTag.info.values) {
                    let value, condition;
                    
                    if (typeof valueItem === 'string') {
                        value = valueItem;
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        value = valueItem.value;
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        value = valueItem.value;
                        condition = null;
                    } else {
                        value = valueItem;
                        condition = null;
                    }
                    
                    if (condition === null || evaluateCondition(condition)) {
                        availableValues.push(value);
                    }
                }
                
                const index = parseInt(e.key) - 1;
                if (index >= 0 && index < availableValues.length) {
                    selectTagValue(currentTag.name, availableValues[index]);
                }
            }
            break;
    }
});
</script>
{% endblock %}
