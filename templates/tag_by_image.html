{% extends "base.html" %}

{% block title %}Tag By Image{% endblock %}

{% block extra_css %}
<style>
    .tag-by-image-layout {
        display: flex;
        gap: 1.5rem;
        height: calc(100vh - 250px);
        min-height: 500px;
        max-height: 900px;
    }

    .tag-sidebar {
        flex: 0 0 400px;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .tag-main {
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 0;
    }

    .media-info {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 1.25rem;
        flex-shrink: 0;
    }

    .media-counter {
        font-size: 1rem;
        color: #667eea;
        font-weight: 500;
        margin-bottom: 0.5rem;
    }

    .media-filename {
        font-size: 1.1rem;
        font-weight: 600;
        color: #333;
        margin-bottom: 0.5rem;
        word-break: break-word;
    }

    .media-path {
        color: #666;
        font-family: monospace;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.05);
        padding: 0.4rem;
        border-radius: 4px;
        word-break: break-all;
        margin-bottom: 0.5rem;
    }

    .media-dimensions {
        font-size: 0.9rem;
        color: #667eea;
        font-weight: 500;
    }

    .dimensions-text {
        background: rgba(102, 126, 234, 0.1);
        padding: 0.3rem 0.6rem;
        border-radius: 4px;
        display: inline-block;
    }

    .tagging-panel {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 1.5rem;
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 1rem;
    }

    .tagging-panel h3 {
        color: #333;
        margin-bottom: 0.5rem;
        font-size: 1.2rem;
        text-align: center;
    }

    .current-tag-info {
        text-align: center;
        margin-bottom: 1rem;
    }

    .current-tag-name {
        font-size: 1.3rem;
        font-weight: 600;
        color: #667eea;
        margin-bottom: 0.5rem;
    }

    .current-tag-description {
        color: #666;
        font-size: 1rem;
        line-height: 1.4;
        margin-bottom: 1rem;
    }

    .tag-options {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
    }

    .tag-option {
        background: white;
        border: 2px solid #ddd;
        border-radius: 8px;
        padding: 1rem;
        cursor: pointer;
        font-size: 1rem;
        font-weight: 500;
        transition: all 0.2s ease;
        text-align: center;
    }

    .tag-option:hover {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
        transform: translateY(-1px);
    }

    .tag-option.selected {
        background: #667eea;
        color: white;
        border-color: #667eea;
    }

    .tag-option.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #f5f5f5;
    }

    .completion-status {
        text-align: center;
        padding: 1rem;
        background: rgba(102, 126, 234, 0.1);
        border-radius: 8px;
        margin-top: auto;
    }

    .completion-status h4 {
        color: #667eea;
        margin-bottom: 0.5rem;
        font-size: 1rem;
    }

    .completion-status p {
        color: #666;
        font-size: 0.9rem;
        margin: 0;
    }

    .navigation {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        flex-shrink: 0;
    }

    .nav-btn {
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 1.5rem;
        transition: all 0.3s ease;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
    }

    .nav-btn:hover:not(:disabled) {
        background: #667eea;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .nav-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .media-display {
        background: rgba(0, 0, 0, 0.8);
        border-radius: 16px;
        padding: 1rem;
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        min-height: 0;
        overflow: hidden;
    }

    .media-display img,
    .media-display video {
        max-width: 100%;
        max-height: 100%;
        border-radius: 8px;
        object-fit: contain;
    }

    .no-media {
        color: #666;
        text-align: center;
        font-size: 1.1rem;
    }

    .fade-in {
        animation: fadeIn 0.3s ease-in;
    }

    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    .no-tags-message {
        text-align: center;
        color: #666;
        font-style: italic;
        padding: 2rem;
    }

    .skip-btn {
        background: rgba(108, 117, 125, 0.9);
        border: none;
        border-radius: 8px;
        padding: 0.75rem 1rem;
        color: white;
        cursor: pointer;
        font-size: 0.9rem;
        font-weight: 500;
        transition: all 0.3s ease;
        margin-top: 1rem;
    }

    .skip-btn:hover {
        background: rgba(108, 117, 125, 1);
        transform: translateY(-1px);
    }

    .progress-indicator {
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 1rem;
        margin-bottom: 0.75rem;
    }

    .progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 0.5rem;
    }

    .progress-fill {
        height: 100%;
        background: #667eea;
        transition: width 0.3s ease;
    }

    .progress-text {
        font-size: 0.9rem;
        color: #666;
        text-align: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="card">
    <h1 style="text-align: center; margin-bottom: 1rem; color: #667eea;">Tag By Image</h1>
    
    <div class="tag-by-image-layout">
        <div class="tag-sidebar">
            <div id="mediaInfo" class="media-info" style="display: none;">
                <div class="media-counter" id="mediaCounter"></div>
                <div class="media-filename" id="mediaFilename"></div>
                <div class="media-path" id="mediaPath"></div>
                <div class="media-dimensions" id="mediaDimensions" style="display: none;">
                    <span class="dimensions-text">
                        <span id="mediaWidth">-</span> × <span id="mediaHeight">-</span>
                    </span>
                </div>
            </div>
            
            <div class="progress-indicator" id="progressIndicator" style="display: none;">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="progress-text" id="progressText"></div>
            </div>
            
            <div class="tagging-panel" id="taggingPanel" style="display: none;">
                <h3>Current Question</h3>
                <div class="current-tag-info">
                    <div class="current-tag-name" id="currentTagName"></div>
                    <div class="current-tag-description" id="currentTagDescription"></div>
                </div>
                
                <div class="tag-options" id="tagOptions">
                    <!-- Tag options will be populated here -->
                </div>
                
                <button class="skip-btn" id="skipBtn" onclick="skipCurrentTag()" style="display: none;">
                    Skip This Tag
                </button>
            </div>
            
            <div class="completion-status" id="completionStatus" style="display: none;">
                <h4>All Tags Complete!</h4>
                <p id="completionText"></p>
            </div>
            
            <div class="navigation" id="navigation" style="display: none;">
                <button class="nav-btn" id="prevBtn" onclick="previousMedia()">‹</button>
                <button class="nav-btn" id="nextBtn" onclick="nextMedia()">›</button>
            </div>
        </div>
        
        <div class="tag-main">
            <div class="media-display" id="mediaDisplay">
                <div class="no-media">No media files found. Upload some files first!</div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let mediaList = [];
let currentIndex = 0;
let tagConfig = {};
let currentTags = {};
let allTags = [];
let currentTagIndex = 0;
let tagDependencies = {}; // Track dependencies for each tag

// Load media list and tag configuration on page load
document.addEventListener('DOMContentLoaded', function() {
    loadMediaList();
    loadTagConfiguration();
});

async function loadMediaList() {
    try {
        const response = await fetch('/api/media');
        mediaList = await response.json();
        
        if (mediaList.length > 0) {
            showMedia(0);
            document.getElementById('navigation').style.display = 'flex';
        } else {
            document.getElementById('mediaDisplay').innerHTML = 
                '<div class="no-media">No media files found. Upload some files first!</div>';
        }
    } catch (error) {
        console.error('Error loading media list:', error);
        document.getElementById('mediaDisplay').innerHTML = 
            '<div class="no-media">Error loading media files.</div>';
    }
}

async function loadTagConfiguration() {
    try {
        const response = await fetch('/api/tags/config');
        tagConfig = await response.json();
        console.log('Loaded tag configuration:', tagConfig);
        
        // Extract all tags in order from the YAML
        if (tagConfig.tags) {
            allTags = Object.keys(tagConfig.tags);
            // Analyze dependencies for each tag
            try {
                analyzeTagDependencies();
            } catch (error) {
                console.error('Error analyzing tag dependencies:', error);
                // Show error in UI
                document.getElementById('mediaDisplay').innerHTML = `
                    <div class="no-media" style="color: #c62828; background: #ffebee; padding: 2rem; border-radius: 8px; border: 1px solid #ef5350;">
                        <h3>Configuration Error</h3>
                        <p><strong>Failed to analyze tag dependencies:</strong></p>
                        <p>${error.message}</p>
                        <p><small>Please check your events_tags.yaml file for syntax errors.</small></p>
                    </div>
                `;
                return;
            }
        }
    } catch (error) {
        console.error('Error loading tag configuration:', error);
        // Show error in UI
        document.getElementById('mediaDisplay').innerHTML = `
            <div class="no-media" style="color: #c62828; background: #ffebee; padding: 2rem; border-radius: 8px; border: 1px solid #ef5350;">
                <h3>Configuration Error</h3>
                <p><strong>Failed to load tag configuration:</strong></p>
                <p>${error.message}</p>
                <p><small>Please check your events_tags.yaml file and ensure the server is running.</small></p>
            </div>
        `;
        tagConfig = { tags: {} };
        allTags = [];
        tagDependencies = {};
    }
}

function analyzeTagDependencies() {
    try {
        tagDependencies = {};
        
        for (const tagName of allTags) {
            try {
                const tagInfo = tagConfig.tags[tagName];
                const dependencies = new Set();
                
                // Check tag-level requirements
                if (tagInfo.req) {
                    const tagDeps = extractVariablesFromCondition(tagInfo.req);
                    tagDeps.forEach(dep => dependencies.add(dep));
                }
                
                // Check value-level requirements
                if (tagInfo.values) {
                    for (const valueItem of tagInfo.values) {
                        if (typeof valueItem === 'object' && valueItem.req) {
                            const valueDeps = extractVariablesFromCondition(valueItem.req);
                            valueDeps.forEach(dep => dependencies.add(dep));
                        }
                    }
                }
                
                tagDependencies[tagName] = Array.from(dependencies);
            } catch (error) {
                console.error(`Error analyzing dependencies for tag ${tagName}:`, error);
                // Continue with other tags, but mark this one as having an error
                tagDependencies[tagName] = [];
                throw new Error(`Failed to analyze dependencies for tag '${tagName}': ${error.message}`);
            }
        }
        
        console.log('Tag dependencies:', tagDependencies);
    } catch (error) {
        console.error('Error analyzing tag dependencies:', error);
        throw new Error(`Failed to analyze tag dependencies: ${error.message}`);
    }
}

function tokenizeCondition(input) {
	const tokens = [];
	let i = 0;
	const length = input.length;
	const isWhitespace = c => /\s/.test(c);
	const isDigit = c => /[0-9]/.test(c);
	const isIdentifierStart = c => /[A-Za-z_]/.test(c);
	const isIdentifierPart = c => /[A-Za-z0-9_]/.test(c);
	while (i < length) {
		const char = input[i];
		if (isWhitespace(char)) { i++; continue; }
		// Operators (two-char first)
		if (i + 1 < length) {
			const two = input.slice(i, i + 2);
			if (two === '&&' || two === '||' || two === '==' || two === '!=' || two === '>=' || two === '<=') {
				tokens.push({ type: 'op', value: two });
				i += 2;
				continue;
			}
		}
		// Single char operators / parens
		if (char === '>' || char === '<' || char === '(' || char === ')') {
			tokens.push({ type: char === '(' || char === ')' ? (char === '(' ? 'lparen' : 'rparen') : 'op', value: char });
			i++;
			continue;
		}
		// String literal
		if (char === '"') {
			let j = i + 1;
			let str = '';
			while (j < length) {
				if (input[j] === '"') { break; }
				// Support escaped quotes \"
				if (input[j] === '\\' && j + 1 < length && input[j+1] === '"') { str += '"'; j += 2; continue; }
				str += input[j];
				j++;
			}
			if (j >= length || input[j] !== '"') {
				throw new Error('Unterminated string literal');
			}
			tokens.push({ type: 'string', value: str });
			i = j + 1;
			continue;
		}
		// Number
		if (isDigit(char)) {
			let j = i;
			while (j < length && (isDigit(input[j]) || input[j] === '.')) j++;
			const numStr = input.slice(i, j);
			const num = parseFloat(numStr);
			if (Number.isNaN(num)) {
				throw new Error(`Invalid number: ${numStr}`);
			}
			tokens.push({ type: 'number', value: num });
			i = j;
			continue;
		}
		// Identifier
		if (isIdentifierStart(char)) {
			let j = i + 1;
			while (j < length && isIdentifierPart(input[j])) j++;
			const ident = input.slice(i, j);
			tokens.push({ type: 'identifier', value: ident });
			i = j;
			continue;
		}
		throw new Error(`Unexpected character: ${char}`);
	}
	return tokens;
}

function extractVariablesFromCondition(condition) {
	const variables = new Set();
	if (!condition) return variables;
	try {
		const tokens = tokenizeCondition(condition);
		for (const t of tokens) {
			if (t.type === 'identifier') variables.add(t.value);
		}
		return variables;
	} catch (error) {
		console.error('Error extracting variables from condition:', condition, error);
		throw new Error(`Failed to parse condition: ${condition}`);
	}
}

function evaluateCondition(condition) {
	if (!condition) return true;
	try {
		const tokens = tokenizeCondition(condition);
		const state = { tokens, index: 0 };
		const result = parseOrExpression(state);
		if (state.index !== tokens.length) {
			throw new Error('Unexpected extra tokens at end of expression');
		}
		return result;
	} catch (error) {
		console.error('Error evaluating condition:', condition, error);
		throw new Error(`Failed to evaluate condition: ${condition}`);
	}
}

function parseOrExpression(state) {
	let value = parseAndExpression(state);
	while (matchOp(state, '||')) {
		const rhs = parseAndExpression(state);
		value = Boolean(value || rhs);
	}
	return value;
}

function parseAndExpression(state) {
	let value = parsePrimary(state);
	while (matchOp(state, '&&')) {
		const rhs = parsePrimary(state);
		value = Boolean(value && rhs);
	}
	return value;
}

function parsePrimary(state) {
	if (matchType(state, 'lparen')) {
		const value = parseOrExpression(state);
		expectType(state, 'rparen', 'Expected closing parenthesis ")"');
		return value;
	}
	return parseComparisonOrIdentifier(state);
}

function parseComparisonOrIdentifier(state) {
	const identToken = expectType(state, 'identifier', 'Expected identifier');
	const leftValRaw = getIdentifierValue(identToken.value);
	// Look ahead for comparator
	const op = peekOp(state);
	if (op && (op === '==' || op === '!=' || op === '>=' || op === '<=' || op === '>' || op === '<')) {
		state.index++; // consume op
		const right = parseValue(state);
		return compareValues(leftValRaw, right, op);
	}
	// Truthiness of identifier when no comparator
	return isTruthy(leftValRaw);
}

function parseValue(state) {
	const tok = current(state);
	if (!tok) throw new Error('Expected value');
	if (tok.type === 'number') { state.index++; return tok.value; }
	if (tok.type === 'string') { state.index++; return tok.value; }
	if (tok.type === 'identifier') { state.index++; return getIdentifierValue(tok.value); }
	throw new Error('Expected a value (number, string, or identifier)');
}

function getIdentifierValue(name) {
	// Read from currentTags; may be undefined
	return currentTags ? currentTags[name] : undefined;
}

function compareValues(left, right, op) {
	// Try numeric compare when both are numeric-like
	const leftNum = left !== undefined && left !== null && left !== '' && !isNaN(Number(left)) ? Number(left) : null;
	const rightNum = right !== undefined && right !== null && right !== '' && !isNaN(Number(right)) ? Number(right) : null;
	if (op === '>' || op === '<' || op === '>=' || op === '<=') {
		if (leftNum === null || rightNum === null) {
			throw new Error(`Numeric comparison requires numbers: ${left} ${op} ${right}`);
		}
		switch (op) {
			case '>': return leftNum > rightNum;
			case '<': return leftNum < rightNum;
			case '>=': return leftNum >= rightNum;
			case '<=': return leftNum <= rightNum;
		}
	}
	// Equality/inequality: if both numeric-like, compare numerically; else string compare
	if (op === '==' || op === '!=') {
		let result;
		if (leftNum !== null && rightNum !== null) {
			result = leftNum === rightNum;
		} else {
			result = `${left}` === `${right}`;
		}
		return op === '==' ? result : !result;
	}
	throw new Error(`Unknown operator: ${op}`);
}

function isTruthy(value) {
	if (value === undefined || value === null) return false;
	if (typeof value === 'number') return value !== 0;
	if (typeof value === 'string') return value.trim() !== '' && value !== '0';
	return Boolean(value);
}

function current(state) { return state.tokens[state.index]; }
function matchType(state, type) {
	const tok = current(state);
	if (tok && tok.type === type) { state.index++; return true; }
	return false;
}
function expectType(state, type, message) {
	const tok = current(state);
	if (!tok || tok.type !== type) { throw new Error(message || `Expected ${type}`); }
	state.index++;
	return tok;
}
function matchOp(state, op) {
	const tok = current(state);
	if (tok && tok.type === 'op' && tok.value === op) { state.index++; return true; }
	return false;
}
function peekOp(state) {
	const tok = current(state);
	return tok && tok.type === 'op' ? tok.value : null;
}

function getOrderedTags() {
    const orderedTags = [];
    const resolvedTags = new Set();
    
    // Process tags in their original order
    for (const tagName of allTags) {
        const dependencies = tagDependencies[tagName] || [];
        const allDependenciesResolved = dependencies.every(dep => resolvedTags.has(dep));
        
        if (allDependenciesResolved) {
            orderedTags.push(tagName);
            resolvedTags.add(tagName);
        } else {
            // Skip this tag for now, it will be processed later when dependencies are resolved
            console.log(`Skipping ${tagName} - dependencies not resolved: ${dependencies.filter(dep => !resolvedTags.has(dep)).join(', ')}`);
        }
    }
    
    // Check for any unresolved tags (circular dependencies)
    const unresolvedTags = allTags.filter(tag => !resolvedTags.has(tag));
    if (unresolvedTags.length > 0) {
        console.warn('Circular dependency detected in tags:', unresolvedTags);
        // Add unresolved tags at the end in original order
        orderedTags.push(...unresolvedTags);
    }
    
    return orderedTags;
}

async function showMedia(index) {
    if (index < 0 || index >= mediaList.length) return;
    
    // Stop any currently playing video before switching
    const currentVideo = document.querySelector('#mediaDisplay video');
    if (currentVideo) {
        currentVideo.pause();
        currentVideo.currentTime = 0;
    }
    
    currentIndex = index;
    const media = mediaList[index];
    
    // Update navigation buttons
    document.getElementById('prevBtn').disabled = index === 0;
    document.getElementById('nextBtn').disabled = index === mediaList.length - 1;
    
    // Update media info
    document.getElementById('mediaInfo').style.display = 'block';
    document.getElementById('mediaCounter').textContent = `${index + 1} of ${mediaList.length}`;
    document.getElementById('mediaFilename').textContent = media.path.split('/').pop();
    document.getElementById('mediaPath').textContent = media.path;
    
    // Load dimensions if available
    try {
        const mediaResponse = await fetch(`/api/media/${index}`);
        const mediaInfo = await mediaResponse.json();
        
        if (mediaInfo.width && mediaInfo.height) {
            document.getElementById('mediaDimensions').style.display = 'block';
            document.getElementById('mediaWidth').textContent = mediaInfo.width;
            document.getElementById('mediaHeight').textContent = mediaInfo.height;
        } else {
            document.getElementById('mediaDimensions').style.display = 'none';
        }
    } catch (error) {
        console.warn('Could not load media dimensions:', error);
        document.getElementById('mediaDimensions').style.display = 'none';
    }
    
    // Load current tags for this media
    await loadCurrentTags(media.path);
    
    // Display media
    displayMedia(media);
    
    // Start the tagging process
    startTaggingProcess();
}

function displayMedia(media) {
    const mediaDisplay = document.getElementById('mediaDisplay');
    
    // Determine if it's an image or video
    const filename = media.path.toLowerCase();
    const isVideo = filename.endsWith('.mp4') || filename.endsWith('.webm') || filename.endsWith('.gif');
    
    if (isVideo) {
        const video = document.createElement('video');
        video.src = '/' + media.path;
        video.controls = true;
        video.autoplay = true;
        video.muted = true;
        video.loop = true;
        video.className = 'fade-in';
        
        // Enable audio after video starts playing
        video.addEventListener('play', () => {
            setTimeout(() => {
                video.muted = false;
            }, 100);
        });
        
        video.onloadstart = () => {
            mediaDisplay.innerHTML = '';
            mediaDisplay.appendChild(video);
        };
        video.onerror = () => {
            mediaDisplay.innerHTML = 
                '<div class="no-media">Error loading video file.</div>';
        };
    } else {
        const img = document.createElement('img');
        img.src = '/' + media.path;
        img.className = 'fade-in';
        img.onload = () => {
            mediaDisplay.innerHTML = '';
            mediaDisplay.appendChild(img);
        };
        img.onerror = () => {
            mediaDisplay.innerHTML = 
                '<div class="no-media">Error loading image file.</div>';
        };
    }
}

async function loadCurrentTags(mediaPath) {
    try {
        const response = await fetch(`/api/tags/media/${encodeURIComponent(mediaPath)}`);
        currentTags = await response.json();
    } catch (error) {
        console.warn('Could not load current tags:', error);
        currentTags = {};
    }
}

function startTaggingProcess() {
    currentTagIndex = 0;
    showNextTag();
}

function showNextTag() {
    try {
        const nextTag = findNextUnansweredTag();
        
        if (nextTag) {
            const shouldShow = showTagQuestion(nextTag);
            if (shouldShow) {
                updateProgress();
            } else {
                // Tag was shown but has no valid options (all conditions unmet)
                // Skip to the next tag
                showNextTag();
            }
        } else {
            showCompletionStatus();
        }
    } catch (error) {
        console.error('Error showing next tag:', error);
        // Display error in the UI
        document.getElementById('taggingPanel').style.display = 'block';
        document.getElementById('completionStatus').style.display = 'none';
        document.getElementById('progressIndicator').style.display = 'none';
        
        document.getElementById('currentTagName').textContent = 'Error';
        document.getElementById('currentTagDescription').textContent = 'An error occurred while processing tags.';
        
        const tagOptionsContainer = document.getElementById('tagOptions');
        tagOptionsContainer.innerHTML = `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
            <strong>System Error:</strong><br>
            ${error.message}<br><br>
            <small>Please check the browser console for more details.</small>
        </div>`;
        
        // Hide skip button since we can't proceed
        document.getElementById('skipBtn').style.display = 'none';
    }
}

function findNextUnansweredTag() {
    try {
        const orderedTags = getOrderedTags();
        
        for (let i = 0; i < orderedTags.length; i++) {
            const tagName = orderedTags[i];
            const tagInfo = tagConfig.tags[tagName];
            
            // Skip if already answered
            if (currentTags[tagName] !== undefined && currentTags[tagName] !== null) {
                continue;
            }
            
            // Check if all dependencies are satisfied
            const dependencies = tagDependencies[tagName] || [];
            const allDependenciesSatisfied = dependencies.every(dep => 
                currentTags[dep] !== undefined && currentTags[dep] !== null
            );
            
            if (!allDependenciesSatisfied) {
                continue; // Skip this tag until dependencies are resolved
            }
            
            // Check if tag is applicable based on req condition
            const tagApplicable = isTagApplicable(tagName, tagInfo);
            if (tagApplicable === true) {
                // Tag is applicable, check if it has any valid values
                const hasValidValues = checkTagHasValidValues(tagName, tagInfo);
                if (hasValidValues === true) {
                    return { name: tagName, info: tagInfo };
                }
                // If hasValidValues is false, skip this tag (no valid options)
                // If hasValidValues is an error, we'll handle it in showTagQuestion
            } else if (tagApplicable === false) {
                // Tag is not applicable, skip it
                continue;
            }
            // If tagApplicable is an error, we'll handle it in showTagQuestion
        }
        return null;
    } catch (error) {
        console.error('Error finding next unanswered tag:', error);
        throw new Error(`Failed to find next tag: ${error.message}`);
    }
}

function isTagApplicable(tagName, tagInfo) {
    try {
        if (!tagInfo.req) {
            return true; // No requirements, always applicable
        }
        
        // Parse and evaluate the req condition
        return evaluateCondition(tagInfo.req);
    } catch (error) {
        console.error('Error checking if tag is applicable:', tagName, tagInfo, error);
        return { error: `Failed to check applicability for tag ${tagName}: ${error.message}` };
    }
}

function checkTagHasValidValues(tagName, tagInfo) {
    try {
        if (tagInfo.values) {
            // Check if any values have valid conditions
            for (const valueItem of tagInfo.values) {
                try {
                    let condition;
                    
                    if (typeof valueItem === 'string') {
                        // Simple string value (backward compatibility)
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        // Conditional value with 'req' clause
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        // Value without condition
                        condition = null;
                    } else {
                        // Fallback for other formats
                        condition = null;
                    }
                    
                    // Check if this value should be shown based on condition
                    if (condition === null || evaluateCondition(condition)) {
                        return true; // Found at least one valid value
                    }
                } catch (error) {
                    console.error('Error processing value item:', valueItem, error);
                    return { error: `Failed to process value for tag ${tagName}: ${error.message}` };
                }
            }
            return false; // No valid values found
        } else if (tagInfo.type === 'int') {
            // Integer tag always has valid options
            return true;
        } else {
            // Default to boolean-like options
            return true;
        }
    } catch (error) {
        console.error('Error checking tag values:', tagName, tagInfo, error);
        return { error: `Failed to check values for tag ${tagName}: ${error.message}` };
    }
}

function showTagQuestion(tag) {
    try {
        document.getElementById('taggingPanel').style.display = 'block';
        document.getElementById('completionStatus').style.display = 'none';
        document.getElementById('progressIndicator').style.display = 'block';
        
        document.getElementById('currentTagName').textContent = tag.name;
        document.getElementById('currentTagDescription').textContent = tag.info.desc || tag.info.description || 'No description available';
        
        const tagOptionsContainer = document.getElementById('tagOptions');
        let html = '';
        let hasValidOptions = false;
        let hasErrors = false;
        
        if (tag.info.values) {
            // Handle conditional values with 'req' clauses
            for (const valueItem of tag.info.values) {
                try {
                    let value, condition;
                    
                    if (typeof valueItem === 'string') {
                        // Simple string value (backward compatibility)
                        value = valueItem;
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        // Conditional value with 'req' clause
                        value = valueItem.value;
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        // Value without condition
                        value = valueItem.value;
                        condition = null;
                    } else {
                        // Fallback for other formats
                        value = valueItem;
                        condition = null;
                    }
                    
                    // Check if this value should be shown based on condition
                    if (condition === null || evaluateCondition(condition)) {
                        html += `<div class="tag-option" onclick="selectTagValue('${tag.name}', '${value}')">${value}</div>`;
                        hasValidOptions = true;
                    }
                } catch (error) {
                    console.error('Error processing value item:', valueItem, error);
                    html += `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
                        <strong>Error:</strong> ${valueItem.value || 'Unknown value'} - ${error.message}
                    </div>`;
                    hasErrors = true;
                }
            }
        } else if (tag.info.type === 'int') {
            // Integer tag - provide common options
            const options = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
            for (const value of options) {
                html += `<div class="tag-option" onclick="selectTagValue('${tag.name}', '${value}')">${value}</div>`;
                hasValidOptions = true;
            }
        } else {
            // Default to boolean-like options
            html += `<div class="tag-option" onclick="selectTagValue('${tag.name}', 'yes')">Yes</div>`;
            html += `<div class="tag-option" onclick="selectTagValue('${tag.name}', 'no')">No</div>`;
            hasValidOptions = true;
        }
        
        if (!hasValidOptions && !hasErrors) {
            // No valid options and no errors - this means all conditions were parsed but none were met
            // Don't show this tag at all, it should be skipped
            return false;
        }
        
        tagOptionsContainer.innerHTML = html;
        
        // Show skip button
        document.getElementById('skipBtn').style.display = 'block';
        return true;
    } catch (error) {
        console.error('Error showing tag question:', tag, error);
        const tagOptionsContainer = document.getElementById('tagOptions');
        tagOptionsContainer.innerHTML = `<div class="tag-option error" style="background: #ffebee; color: #c62828; border-color: #ef5350;">
            <strong>Error displaying tag:</strong> ${tag.name}<br>
            ${error.message}
        </div>`;
        return true; // Show the error
    }
}

function updateProgress() {
    const totalApplicableTags = countApplicableTags();
    const completedTags = countCompletedTags();
    const progressPercent = totalApplicableTags > 0 ? (completedTags / totalApplicableTags) * 100 : 0;
    
    document.getElementById('progressFill').style.width = `${progressPercent}%`;
    document.getElementById('progressText').textContent = 
        `${completedTags}/${totalApplicableTags} tags completed`;
}

function countApplicableTags() {
    const orderedTags = getOrderedTags();
    let count = 0;
    
    for (const tagName of orderedTags) {
        const tagInfo = tagConfig.tags[tagName];
        const dependencies = tagDependencies[tagName] || [];
        
        // Check if all dependencies are satisfied
        const allDependenciesSatisfied = dependencies.every(dep => 
            currentTags[dep] !== undefined && currentTags[dep] !== null
        );
        
        if (allDependenciesSatisfied && isTagApplicable(tagName, tagInfo)) {
            count++;
        }
    }
    return count;
}

function countCompletedTags() {
    const orderedTags = getOrderedTags();
    let count = 0;
    
    for (const tagName of orderedTags) {
        const tagInfo = tagConfig.tags[tagName];
        const dependencies = tagDependencies[tagName] || [];
        
        // Check if all dependencies are satisfied
        const allDependenciesSatisfied = dependencies.every(dep => 
            currentTags[dep] !== undefined && currentTags[dep] !== null
        );
        
        if (allDependenciesSatisfied && 
            isTagApplicable(tagName, tagInfo) && 
            currentTags[tagName] !== undefined && 
            currentTags[tagName] !== null) {
            count++;
        }
    }
    return count;
}

function showCompletionStatus() {
    document.getElementById('taggingPanel').style.display = 'none';
    document.getElementById('progressIndicator').style.display = 'none';
    document.getElementById('completionStatus').style.display = 'block';
    
    const totalApplicableTags = countApplicableTags();
    const completedTags = countCompletedTags();
    
    document.getElementById('completionText').textContent = 
        `All ${completedTags} applicable tags completed for this media!`;
    
    // Auto-advance to next image after a short delay
    setTimeout(() => {
        if (currentIndex < mediaList.length - 1) {
            nextMedia();
        }
    }, 2000);
}

async function selectTagValue(tagName, value) {
    // Save the tag value
    currentTags[tagName] = value;
    
    // Save to server
    await saveCurrentTags();
    
    // Show next tag or completion
    showNextTag();
}

async function skipCurrentTag() {
    // Mark current tag as skipped (set to null)
    const currentTag = findNextUnansweredTag();
    if (currentTag) {
        currentTags[currentTag.name] = null;
        await saveCurrentTags();
        showNextTag();
    }
}

async function saveCurrentTags() {
    if (mediaList.length === 0) return;
    
    const currentMedia = mediaList[currentIndex];
    
    try {
        const response = await fetch(`/api/tags/media/${encodeURIComponent(currentMedia.path)}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(currentTags)
        });
        
        if (!response.ok) {
            throw new Error('Failed to save tags');
        }
    } catch (error) {
        console.error('Error saving tags:', error);
        // Could show a user-friendly error message here
    }
}

async function previousMedia() {
    if (currentIndex > 0) {
        await showMedia(currentIndex - 1);
    }
}

async function nextMedia() {
    if (currentIndex < mediaList.length - 1) {
        await showMedia(currentIndex + 1);
    }
}

// Keyboard navigation
document.addEventListener('keydown', async (e) => {
    if (mediaList.length === 0) return;
    
    switch(e.key) {
        case 'ArrowLeft':
            e.preventDefault();
            await previousMedia();
            break;
        case 'ArrowRight':
            e.preventDefault();
            await nextMedia();
            break;
        case 'Escape':
            e.preventDefault();
            skipCurrentTag();
            break;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case '0':
            e.preventDefault();
            // Quick number selection for current tag
            const currentTag = findNextUnansweredTag();
            if (currentTag && currentTag.info.values) {
                // Get available values (filtered by conditions)
                const availableValues = [];
                for (const valueItem of currentTag.info.values) {
                    let value, condition;
                    
                    if (typeof valueItem === 'string') {
                        value = valueItem;
                        condition = null;
                    } else if (valueItem.value && valueItem.req) {
                        value = valueItem.value;
                        condition = valueItem.req;
                    } else if (valueItem.value) {
                        value = valueItem.value;
                        condition = null;
                    } else {
                        value = valueItem;
                        condition = null;
                    }
                    
                    if (condition === null || evaluateCondition(condition)) {
                        availableValues.push(value);
                    }
                }
                
                const index = parseInt(e.key) - 1;
                if (index >= 0 && index < availableValues.length) {
                    selectTagValue(currentTag.name, availableValues[index]);
                }
            }
            break;
    }
});
</script>
{% endblock %}
